Legend:     [x] Finished task   [-] Partially complete task   [ ] Unstarted task
             -  Information      o  Option

High importance:

[-] const
	[x] Parsing
	[x] Type annotation
	[ ] Type compatibility/equality
        - No qualifiers dropped, qual smearing if added
	[x] Assignable
		[x] structs with const fields
	[x] Fields of const structs/unions const themselves
    [ ] (const)[] => const ()[]
[ ] Review type compatibility
	[ ] Cast compatibility
[ ] Numeric type coercion: widening & narrowing
[-] Type completeness
	[ ] Incomplete arrays
	[ ] Cast to incomplete
[x] Varargs
[x] extern
[-] static
    [ ] Function linkage
[-] Modules
    [-] Separated namespaces
    [x] Include once only
	[ ] Infinite loops

Medium:

[-] Platform support
	[-] 64-bit
		[-] Windows
		[-] Linux
	[x] 32-bit
	[-] Cross-compilation by command line
[ ] Unsigned integers
[ ] Floating point numbers
[ ] long (long long)
[ ] wchar_t
[ ] x ?: y
[ ] String literal concatenation
[-] Closures
	- Syntax?
	[x] Capture-less lambdas
[x] Designated initializers in compound literals
[-] auto type inference
    [ ] Pointer and array base type
    [ ] Errors for auto function return and param types
    [ ] Type qualifiers
    [ ] Don't allow an inferred var in its own init
    [ ] (auto[]) {...} ?
[ ] assert
[ ] Warnings
	[ ] main conformance
	[ ] Unused value
	[ ] Statement without effect
	[ ] Empty decl
	[ ] Empty block body, if (...);
	[ ] Assignment as condition
[ ] AST optimizer
	[ ] Strength reduction
	[ ] Constant folding
	[ ] Constant propogation?
	[ ] Factorization (CSE)
	[ ] Operand commutation => Strahler number
[ ] Octal and hex literals

Low:

[ ] Unicode
[ ] Pretty printing control by command line
[-] New IR
[ ] Lexer errors
    [ ] Multichar
    [ ] EOF without EOL
    [ ] Unended comment / string / char
    [ ] Unrecognised escape
	[ ] Newline in string
	[ ] Suffix on integer literal
[ ] Modules
    [ ] header & using, special meaning?
	[ ] Different dialect?
        - No impls
		- No static
		- No globals (except extern)
[ ] Initializing arrays from strings
[ ] Expand eval.c
    [ ] String literals and indexing
    [ ] Records and arrays
[-] Full ABI conformance
	- structs, bah
	- GCC
	- Clang
	  Doing something weird with struct returning, LTO across module boundaries?


Other issues:

[ ] Add symbol size back to debug output
[ ] Use jump tables in tag string lookup
[-] Use vector in:
	[ ] ast
	[x] sym
[ ] Declare structs inside modules, not their headers, if not part of the interface
[ ] Change {int,hash}{set,map} from typedefs to unitary structs to prevent casting
[ ] Use gcov to find which branches are usually taken => reorder ifs (particularly switch replacements)

Parser:

[-] Symbol shadowing
[ ] Get tokenMatch to guess whether to skip based on similarity of tokens
[ ] Complain about keywords as idents
[ ] Implicit declarations on error
[ ] Error for unnamed structs/unions that don't define variables
	- OUTSIDE structs/unions (those would be anonymous, not unnamed... because the difference is obvious)
[ ] Missing semicolon after decl (more?) shouldn't cascade so terribly

Semantic analyzer:

[ ] Array size detection (basic x[] = {...})
    - analyzer-decl.c
[x] Initialization/impl_n of extern and typedef
[ ] Rules for cast compatibility
[ ] Ternary: allow compatible unequal?
[ ] typedef unification
[ ] On error expected type, chain types together and only complain again if found type not in chain?
[ ] eval.c: casts, target sizes
[ ] Improve errors for compound initializations: symbol name, type
[ ] Very strict enum coercion: from enum to integer of same size?

Emitter:

[-] Remove global state
	[x] labels
	[ ] registers
	[ ] debug?
[-] Short circuit ops optimization
    - If flag condition is the same, just return flags :D
      This chains well
[ ] Extra layer between emitter and assembly?
    - Expand operand?
    - Maybe: have a layer that takes expressions and an operation,
      sends them off to emitterValue, handles operands and reg
      placement.
[ ] Use temporary file (or pipe?) for output unless -[sSx]
[ ] Cache sym size
	=> move to analyzer?
	=> as well as offset
	=> offsetOf?
	=> eval.c
	o OR not, handle in IR?
[ ] Optimize pointer indexing similar to array indexing
[ ] Fix pointer arithmetic
